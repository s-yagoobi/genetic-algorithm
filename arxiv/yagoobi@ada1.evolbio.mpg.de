
"""
genetic algorithm-coalescence time

"""


from mpi4py import MPI
import networkx as nx
import numpy as np
import random
import time
import logging
import platform
from scipy import linalg 

logging.basicConfig(format='%(asctime)s:%(levelname)s:%(message)s', level=logging.DEBUG)

from parameters import population_size,\
     number_of_GA_iterations,\
    number_of_parents,\
    number_of_realization,\
    fitness,\
    b,\
    top_parents

#===============================================================================================================================
def random_graphs():
    '''generating number_of_parents initial random graphs'''
    i=0
    RG=[]
    
    while len(RG) !=number_of_parents:
        RG.append(get_RG(i))
        i += 1
        
    return RG

#==============================================================================================================================
def get_RG(seed=0):
    """
    Generate a random graph
    
    :param seed: The random seet
    :type  seed: int
    
    """
    
    random.seed(seed)
    
    # Loop until we find a connected graph.
    while True:
        matrix1 = np.array([np.random.randint(2) for _ in range(b)]) # generate a random matrix of size b

        upper_indices=np.triu_indices(population_size, k = 1)
        lower_indices=(upper_indices[1],upper_indices[0])

        G=np.zeros([population_size,population_size])
        G[upper_indices]=matrix1
        G[lower_indices]=matrix1
        G1 = nx.from_numpy_array(G)

        if (nx.is_connected(G1)==True):
            return G
#==============================================================================================================================        
def fix_prob(W):
    """
    clculating the linear term of fixation probabilitty using coalescence times

    Parameters
    ----------
    W : array
        adjacency matrix.
    Ntau : integer
        number of independent coalescence times.
    N : integer
        population size.

    Returns
    -------
    rho1 : float
        linear term of fixation probability.

    """
    
    
    wdeg = np.sum(W,axis=1)        # weighted degree
    N=len(wdeg)
    Ntau=int(N*(N-1)/2)
    wdeg1=np.zeros([N,N])
    for i in range(N):
        wdeg1[i,:]=wdeg
    
    wdeg1=np.transpose(wdeg1)

    #one step probability
    P=np.divide(W,wdeg1)
    Temp = np.sum(P,axis=0)       # node temperature
    #Determine indices of non-zero taus
    ind = np.zeros([Ntau,2],int)
    k = 0
    for i in range(N):
        for j in range(i+1,N):
        
            ind[k,:]= (i,j)
            k = k + 1
    # Determine A coefficient matrix
    A = np.zeros([Ntau,Ntau])

    #Determine b constant matrix
    b=np.zeros([Ntau])

    for row in range(Ntau):
    
        b[row]=2/(Temp[ind[row,0]]+Temp[ind[row,1]])
        for col in range(row + 1 , Ntau):
        
            if ind[row,0] == ind[col,0]:
                A[row,col] = P [ind[col,1],ind[row,1]]/(Temp[ind[row,0]]+Temp[ind[row,1]])
                A[col,row] = P [ind[row,1],ind[col,1]]/(Temp[ind[col,0]]+Temp[ind[col,1]])
            
            elif (ind[row,1] == ind[col,0]):
                A[row,col] = P [ind[col,1],ind[row,0]]/(Temp[ind[row,0]]+Temp[ind[row,1]])
                A[col,row] = P [ind[row,0],ind[col,1]]/(Temp[ind[col,0]]+Temp[ind[col,1]])
            elif (ind[row,1] == ind[col,1]):
                A[row,col] = P [ind[col,0],ind[row,0]]/(Temp[ind[row,0]]+Temp[ind[row,1]])
                A[col,row] = P [ind[row,0],ind[col,0]]/(Temp[ind[col,0]]+Temp[ind[col,1]])
    #calculate coalescence time
    tau=np.matmul(b, linalg.inv(np.identity(Ntau)-A))


    W1=np.sum(W, axis=0) #sum of the  weight of outgoing edges

    W2=np.reciprocal(W1) # reciprocal of weigthed degree

    rho1=0
    for row in range(Ntau):
        rho1+=tau[row]*W[ind[row,0],ind[row,1]]/ (W1[ind[row,0]]* W1[ind[row,1]])
    

    #the linear term term of fixation probability    
    rho1=rho1/(N*np.sum(W2))    
    return rho1                
        
#=====================================================================================================================
        
def cross_over(G1,G2):
    parents1=G1[np.triu_indices(population_size, k = 1)] #pick up the upper triangle elements of the matrix
    #print(parents1)
    parents2=G2[np.triu_indices(population_size, k = 1)]
    
    #the process of recombination         
    birth1=np.concatenate((parents1,parents2),axis=0)
    
    random.shuffle(birth1)
    
    birth=np.zeros([len(parents1)])
    birth=birth1[0:len(parents1)]
       
    #mutation
    rand=random.randrange(len(birth))
    birth[rand]=abs(birth[rand]-1)
        
    #build the adjacency matrix for the offspring
    offspring=np.zeros([population_size,population_size])
    upper_indices=np.triu_indices(population_size, k = 1)
    lower_indices=(upper_indices[1],upper_indices[0])
    offspring[upper_indices]=birth
    offspring[lower_indices]=birth
    return offspring
#================================================================================================================

def new_offspring(random_graphs, fixation_probabilities):
    #crossover
    start = time.time()
    # choose two individual among the highest fix-prob to mate
    top_performers = np.argsort(fixation_probabilities)[number_of_parents - top_parents:number_of_parents]

    parents = np.random.choice(
        top_performers,
        size=2,
        replace=False,
    )
    try:
        G1 = random_graphs[parents[0]]
        G2 = random_graphs[parents[1]]
    except:
        print("rank = {}, parents = ".format(rank, parents), flush=True)
        raise

    offspring = cross_over(G1, G2)

    # check if the offspring is connected
    offspring_matrix = np.asmatrix(offspring)
    offspring_graph = nx.from_numpy_matrix(offspring_matrix)

    if nx.is_connected(offspring_graph):
        new_family = [G1, G2, offspring]
        Fixation_new_family = [fixation_probabilities[parents[0]], fixation_probabilities[parents[1]], fix_prob(offspring)]
        max_ind = Fixation_new_family.index(max(Fixation_new_family))
        offspring=new_family[max_ind]
        fix_prob_offspring=max(Fixation_new_family)
    else:
        new_family = [G1, G2]
        Fixation_new_family = [fixation_probabilities[parents[0]], fixation_probabilities[parents[1]]]
        max_ind = Fixation_new_family.index(max(Fixation_new_family))
        offspring=new_family[max_ind]
        fix_prob_offspring=max(Fixation_new_family)

    return offspring, fix_prob_offspring, time.time()-start

#========================================================================================================
    
def new_generation(random_graphs, fixation_probabilities):

    offspring, fix_prob_offspring, duration = new_offspring(random_graphs, fixation_probabilities)

    return offspring, fix_prob_offspring
#===============================================================================================================================
# Setup the MPI communication
comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

if rank == 0:
    print("*****************************")
    print("* Welcome to MPI            *")
    print("*                           *")
    print("* MPI size = {}              *".format(size))
else:
    pass
comm.barrier()
print("* MPI rank = {}              *".format(rank))

# Calculate the fixation probability of an initial pool of random graphs
RG = None
fixation_probabilities = None
if rank == 0:
    RG = random_graphs()
    fixation_probabilities=[]
    for g in RG:
        fixation_probabilities.append(fix_prob(g))
    fixation_probabilities = np.asarray(fixation_probabilities)

# Master process

for j in range(number_of_GA_iterations):

    RG = comm.bcast(RG, root=0)
    fixation_probabilities = comm.bcast(fixation_probabilities, root=0)

    if rank == 0:
        print("************************************")
        print(" Generation {}".format(j+1))
        print(" Top performers:")
        top_performers = np.argsort(fixation_probabilities)[number_of_parents - top_parents:number_of_parents]
        print(top_performers)
        print("************************************")

    my_RGs = []
    my_FPs = []
    for i in range(number_of_parents):
        if i % size == rank:
            logging.info("Starting parent #%d with rank %d on node %s.", i,
                    rank, platform.node())
            rg, fp = new_generation(RG, fixation_probabilities)
            my_RGs.append(rg)
            my_FPs.append(fp)

    RG = comm.gather(my_RGs, root=0)
    fixation_probabilities = comm.gather(my_FPs, root=0)

    # Unpack
    if rank == 0:
        RG = [rg for y in RG for rg in y]
        fixation_probabilities = [fp for y in fixation_probabilities for fp in y]

        
